{"instance_id": "7", "selected_database": "archeology", "query": "Show me each site's code and name, along with the average temperature, humidity, and illumination levels. I'd also like to see the average Environmental Suitability Index for each site, classified into quartiles, to understand the range of conditions. Finally, classify each site into Environmental Condition Classification System according to average ESI value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["\n/*\n * SQL Intent: Analyze environmental conditions at scanning sites to determine optimal scanning locations\n * Knowledge Used: #7 (Environmental Suitability Index - ESI), #15 (Optimal Scanning Conditions) #50\n * Advanced Functions: ABS(), POWER(), CASE expressions, Window functions (NTILE())\n */\n\n-- Step 1: Calculate Environmental Suitability Index (ESI) for each environment record\nWITH environment_analysis AS (\n    SELECT \n        se.zoneref AS site_code,\n        se.ambictemp,\n        se.humepct,\n        se.illumelux,\n        -- Calculate ESI based on Knowledge #7\n        100 - 2.5 * ABS(se.ambictemp - 20) - \n        POWER(ABS((se.humepct - 50) / 2), 1.5) - \n        600 / (se.illumelux + 100) AS esi\n    FROM scanenvironment se\n)\n\n-- Step 2: Aggregate environmental metrics by site and classify scanning conditions\nSELECT \n    s.zoneregistry AS site_code,\n    s.zonelabel AS site_name,\n    ROUND(AVG(ea.ambictemp)::numeric, 1) AS avg_temperature_c,\n    ROUND(AVG(ea.humepct)::numeric, 1) AS avg_humidity_pct,\n    ROUND(AVG(ea.illumelux)::numeric, 1) AS avg_illumination_lux,\n    ROUND(AVG(ea.esi)::numeric, 1) AS avg_esi,\n    -- Categorize sites by environmental suitability quartile\n    NTILE(4) OVER (ORDER BY AVG(ea.esi)) AS esi_quartile,\n    -- Classify scanning conditions based on Knowledge #15\n    CASE \n        WHEN AVG(ea.esi) > 85 THEN 'Optimal Scanning Conditions'\n        WHEN AVG(ea.esi) > 70 THEN 'Good Scanning Conditions'\n        WHEN AVG(ea.esi) > 50 THEN 'Acceptable Scanning Conditions'\n        ELSE 'Challenging Scanning Conditions'\n    END AS scanning_condition_class,\nFROM sites s\nJOIN environment_analysis ea ON s.zoneregistry = ea.site_code\nGROUP BY s.zoneregistry, s.zonelabel\nORDER BY avg_esi DESC;\n"], "external_knowledge": [7, 15, 50], "test_cases": [], "category": "Query", "high_level": false, "conditions": {"decimal": 1, "distinct": false}, "difficulty_tier": "Medium"}
{"instance_id": "M_5", "selected_database": "archeology", "query": "For each project, identify and delete redundant scans while keeping only the one with the best Scan Quality Score and ensuring Comprehensive Coverage. The query should calculate SQS and rank scans within each project based on their quality. Only scans with a quality rank greater than 1 should be deleted. The output should return the questregistry and arcref of the deleted scans.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["\n/* Intent: Delete redundant scans while keeping those with best quality (SQS) and ensuring comprehensive coverage\nKnowledge used: \n- #3 (Scan Quality Score): SQS = (10/SRI)^1.5 × (SCE/100) × (1 - NoiseDb/30)^2\n- #11 (Comprehensive Coverage): CoverPct ≥ 95 AND LapPct ≥ 30\nAdvanced features: DELETE with CTEs, Window functions, Multiple-step calculations */\n\nDELETE FROM scans\nUSING (\n    WITH scan_metrics AS (\n        -- Step 1: Calculate SRI (Scan Resolution Index) \n        SELECT s.questregistry,\n               s.arcref,\n               sp.scanresolmm,\n               sp.pointdense,\n               sp.coverpct,\n               sp.lappct,\n               sp.noisedb,\n               (LOG(10, sp.scanresolmm * 1000) / LOG(10, sp.pointdense) * 5) AS sri\n        FROM scans s\n        JOIN scanpointcloud sp USING (arcref)\n        -- Filter 1: Only consider scans that don't meet comprehensive coverage standard\n        WHERE sp.coverpct < 95 OR sp.lappct < 30\n    ),\n    quality_scores AS (\n        -- Step 2: Calculate full SQS incorporating both SCE and noise factors\n        SELECT questregistry,\n               arcref,\n               coverpct,\n               lappct,\n               -- Complete SQS calculation per Knowledge #3\n               POWER(10/sri, 1.5) * \n               ((coverpct * (1 + lappct/100 * (1 - coverpct/100)))/100) *\n               POWER(1 - noisedb/30, 2) AS sqs,\n               -- Rank scans within each project based on quality\n               ROW_NUMBER() OVER (\n                   PARTITION BY arcref \n                   ORDER BY \n                       -- First prioritize scans meeting coverage standards\n                       CASE WHEN coverpct >= 95 AND lappct >= 30 THEN 1 \n                            ELSE 2 END,\n                       -- Then order by SQS for quality\n                       POWER(10/sri, 1.5) * \n                       ((coverpct * (1 + lappct/100 * (1 - coverpct/100)))/100) *\n                       POWER(1 - noisedb/30, 2) DESC\n               ) AS quality_rank\n        FROM scan_metrics\n    )\n    -- Step 3: Select redundant scans for deletion\n    SELECT questregistry\n    FROM quality_scores\n    WHERE quality_rank > 1  -- Keep only the best scan per project\n) redundant\nWHERE scans.questregistry = redundant.questregistry\nRETURNING scans.questregistry, scans.arcref;\n"], "external_knowledge": [3, 11], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # Identify a specific scan expected to be deleted based on the logic/data (using the example from original test)\n    expected_deleted_questregistry = 'ASD648638'\n    expected_deleted_arcref = 'PR8078'\n\n    assert pred_query_result is not None, \"DELETE query execution failed or did not return results via RETURNING.\"\n    if not pred_query_result:\n        print(\"Warning: DELETE statement did not return any rows. No redundant scans found or query logic error.\")\n        count_after_sql = \"SELECT COUNT(*) FROM scans;\"\n        count_after_result = execute_queries([count_after_sql], db_name, conn)\n        final_scan_count = count_after_result[0][0][0] if count_after_result and count_after_result[0] else -1\n        return 1 # Test passes if no rows were meant to be deleted\n\n    returned_data = pred_query_result[0]\n    num_deleted_returned = len(returned_data)\n    assert num_deleted_returned > 0, \"RETURNING clause should return at least one row.\"\n    assert len(returned_data) == 2, f\"RETURNING clause should return 2 columns (questregistry, arcref), but got {len(returned_data[0])}\"\n\n    # Check if the specific expected deletion was returned\n    found_expected_deletion = any(row[0] == expected_deleted_questregistry and row[1] == expected_deleted_arcref for row in pred_query_result)\n    assert found_expected_deletion,         f\"Expected deleted scan ({expected_deleted_questregistry}, {expected_deleted_arcref}) not found in RETURNING output.\"\n\n    # 2. Check table state AFTER deletion\n    count_after_sql = \"SELECT COUNT(*) FROM scans;\"\n    count_after_result = execute_queries([count_after_sql], db_name, conn)\n    final_scan_count = count_after_result[0][0][0] if count_after_result and count_after_result[0] else -1\n    assert final_scan_count != -1, \"Failed to get final scan count.\"\n\n    # Verify the specific deleted scan is no longer in the table\n    check_deleted_sql = f\"SELECT COUNT(*) FROM scans WHERE questregistry = '{expected_deleted_questregistry}';\"\n    check_deleted_result = execute_queries([check_deleted_sql], db_name, conn)\n    assert check_deleted_result[0][0][0] == 0,         f\"Scan {expected_deleted_questregistry} was expected to be deleted but still exists in the table.\"\n\n    return 1\n"], "category": "Management", "high_level": false, "conditions": {"decimal": -1, "distinct": false}, "difficulty_tier": "Medium"}

