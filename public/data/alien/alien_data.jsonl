{"instance_id": "5", "selected_database": "alien", "query": "Show me a breakdown of signal modulation types with at least 5 occurrences. For each modulation type, display the modulation type, the number of signals, the average Modulation Complexity Score (MCS), and average signal-to-noise ratio (SNR). Also include a detailed JSON with each signal's MCS and SNR values. Keys are the signal record IDs, and values are inner objects containing two fields: `mcs` – the signal’s MCS value, and `snr` – the SNR value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["/*\nIntent: Evaluate effectiveness of different modulation types\nKnowledge Used: MCS (id:30)\nAdvanced Features: JSON functions, advanced aggregation\n*/\nSELECT \n    s.ModType,\n    COUNT(*) AS signal_count,\n    AVG(s.ModIndex * (1 + (1 - ABS(s.FreqDriftHzs)/(s.FreqMhz*1000)) * \n        s.SigDurSec/(1 + s.DoppShiftHz/1000)) *\n        CASE \n            WHEN s.ModType = 'AM' THEN 2\n            WHEN s.ModType = 'FM' THEN 1.5\n            ELSE 1\n        END) AS avg_mcs,\n    AVG(s.SnrRatio) AS avg_snr,\n    JSON_OBJECT_AGG(\n        s.SignalRegistry,\n        JSON_BUILD_OBJECT(\n            'mcs', s.ModIndex * (1 + (1 - ABS(s.FreqDriftHzs)/(s.FreqMhz*1000)) * \n                   s.SigDurSec/(1 + s.DoppShiftHz/1000)) *\n                   CASE \n                       WHEN s.ModType = 'AM' THEN 2\n                       WHEN s.ModType = 'FM' THEN 1.5\n                       ELSE 1\n                   END,\n            'snr', s.SnrRatio\n        )\n    ) AS signal_details\nFROM Signals s\nWHERE s.ModType IS NOT NULL\nGROUP BY s.ModType\nHAVING COUNT(*) > 5;"], "external_knowledge": [30], "test_cases": [], "category": "Query", "high_level": true, "conditions": {"decimal": -1, "distinct": false}, "difficulty_tier": "Medium"}
{"instance_id": "M_3", "selected_database": "alien", "query": "Create a view called vw_observation_quality that calculates and displays the Observation Quality Factor (OQF) for each signal detection. Please include the observatory station, telescope registry, signal registry, along with the computed AOI, LIF, and OQF values in the view output.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["-- Create a view to show observation quality factors.\n-- Intent: Join Observatories, Telescopes, and Signals to compute an \"Observation Quality Factor (OQF)\"\n--         that is based on AOI, LIF, and pointing accuracy.\n--\n-- Step 1: Use a CTE to join three tables using INNER JOIN.\n-- Step 2: Compute AOI = AtmosTransparency * (1 - HumidityRate/100) * (1 - 0.02 * WindSpeedMs).\n-- Step 3: Compute LIF = (1 - LunarDistDeg/180) * (1 - AtmosTransparency).\n-- Step 4: Compute OQF = AOI * (1 - LIF) * (CASE WHEN PointAccArc < 2 THEN 1 ELSE 2/PointAccArc END).\n--\n-- Advanced features used: CASE expressions, arithmetic operations, and a CTE for cleaner joins.\n--\n-- Knowledge Used:\n--   \"Atmospheric Observability Index (AOI)\" [KB id:1],\n--   \"Lunar Interference Factor (LIF)\" [KB id:9],\n--   and \"Observation Quality Factor (OQF)\" [KB id:32].\nCREATE OR REPLACE VIEW vw_observation_quality AS\nWITH calc AS (\n  SELECT\n    o.ObservStation,\n    t.TelescRegistry,\n    s.SignalRegistry,\n    o.AtmosTransparency,\n    o.HumidityRate,\n    o.WindSpeedMs,\n    o.LunarDistDeg,\n    t.PointAccArc,\n    -- Compute AOI based on environmental conditions.\n    (o.AtmosTransparency * (1 - o.HumidityRate/100.0) * (1 - 0.02 * o.WindSpeedMs)) AS aoi,\n    -- Compute LIF based on lunar distance and transparency.\n    ((1 - o.LunarDistDeg/180.0) * (1 - o.AtmosTransparency)) AS lif\n  FROM Observatories o\n  INNER JOIN Telescopes t ON o.ObservStation = t.ObservStation\n  INNER JOIN Signals s ON s.TelescRef = t.TelescRegistry\n)\nSELECT\n  ObservStation,\n  TelescRegistry,\n  SignalRegistry,\n  aoi,\n  lif,\n  aoi * (1 - lif) * (CASE WHEN PointAccArc < 2 THEN 1 ELSE 2.0/PointAccArc END) AS oqf\nFROM calc;\n"], "external_knowledge": [1, 9, 32], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    tolerance = 0.0001  # Allowable floating point difference\n    # Define a verification query that joins the view with base tables to compute expected oqf.\n    verification_sql = \"\"\"\n    SELECT \n        v.oqf AS view_oqf,\n        (calc.aoi * (1 - calc.lif) * \n            (CASE WHEN calc.PointAccArc < 2 THEN 1 ELSE 2.0/calc.PointAccArc END)\n        ) AS expected_oqf\n    FROM vw_observation_quality v\n    JOIN (\n        SELECT\n            o.ObservStation,\n            t.TelescRegistry,\n            s.SignalRegistry,\n            (o.AtmosTransparency * (1 - o.HumidityRate/100.0) * (1 - 0.02 * o.WindSpeedMs)) AS aoi,\n            ((1 - o.LunarDistDeg/180.0) * (1 - o.AtmosTransparency)) AS lif,\n            t.PointAccArc\n        FROM Observatories o\n        INNER JOIN Telescopes t ON o.ObservStation = t.ObservStation\n        INNER JOIN Signals s ON s.TelescRef = t.TelescRegistry\n    ) calc\n    ON v.ObservStation = calc.ObservStation\n    AND v.TelescRegistry = calc.TelescRegistry\n    AND v.SignalRegistry = calc.SignalRegistry;\n    \"\"\"\n    # Execute verification query.\n    pred_verification_result, _, _ = execute_queries(verification_sql, db_name, conn)\n    # For each returned row, assert that view_oqf is within tolerance of expected_oqf.\n    for row in pred_verification_result:\n        view_oqf = float(row[0])\n        expected_oqf = float(row[1])\n        assert abs(view_oqf - expected_oqf) < tolerance, (\n            f\"Predicted view error: For row with ObservStation/TelescRegistry/SignalRegistry, \"\n            f\"view oqf ({view_oqf}) does not match expected oqf ({expected_oqf}) within tolerance.\"\n        )\n    "], "category": "Management", "high_level": true, "conditions": {"decimal": -1, "distinct": false}, "difficulty_tier": "Medium"}
